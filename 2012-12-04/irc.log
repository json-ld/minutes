[10:06]	<manu1>	Agenda: http://lists.w3.org/Archives/Public/public-linked-json/2012Dec/0004.html
[10:06]	<manu1>	scribe: manu1
[10:07]	<manu1>	Topic: Algorithm updates
[10:08]	<manu1>	manu: The algorithms need to be revised.
[10:09]	<manu1>	manu: Dave Longley and I are going to go through and clean up the algorithms near Dec. 15th
[10:10]	<manu1>	markus: I'm going to update my JSON-LD processor this week, I hope to update the algorithms as well.
[10:10]	<manu1>	niklas: Hopefully, I'm going to have time to get back to the RDFa Labs stuff (which is JSON-LD under the hood)
[10:10]	<tidoust>	[one thing to clean up: remove statements such as "If context is a string, it must have a lexical form of IRI" since that's a syntax consideration (and it's defined in the syntax spec), not a processing step]
[10:11]	<manu1>	niklas: I copied some of the JSON-LD implementation stuff as a result, if I have time I will be able to read through it and comment on it. I'd really like to be able to factor out the framing stuff.
[10:12]	<manu1>	Topic: ISSUE-157: JSON-LD mapping to RDF terminology
[10:12]	<tidoust>	voip: mute me
[10:12]	<voip-ld>	tidoust has been muted.
[10:12]	<manu1>	https://github.com/json-ld/json-ld.org/issues/157
[10:13]	<manu1>	manu: Richard was going to write this section, was too busy, Markus is going to write this up.
[10:13]	<mlnt>	http://json-ld.org/spec/latest/json-ld-syntax/#data-model
[10:13]	<manu1>	markus: I took an action to take over the RDF re-write, I put something in the syntax spec which is more-or-less what Richard has in his draft. It has a few clarifications and some things he misunderstood.
[10:13]	-->|	gkellogg (~gregg@c-98-248-150-91.hsd1.ca.comcast.net) has joined #json-ld
[10:14]	<mlnt>	http://json-ld.org/spec/latest/json-ld-syntax/#relationship-to-rdf
[10:14]	<voip-ld>	Gregg Kellogg (SIP/10.0.1.18-00000081) has joined the conference.
[10:14]	<manu1>	markus: That should explain the whole data model in all of it's detail and make it easy to map it to RDF. The relationship to RDF section is quite short at the moment, there are not many differences.
[10:14]	<manu1>	markus: We need some reviews of those two sections, don't know if they're happy with it yet.
[10:14]	<manu1>	manu: We strongly advise against using bnodes for properties, right?
[10:15]	<manu1>	markus: yes.
[10:15]	<tidoust>	q+
[10:15]	<voip-ld>	Added tidoust to the speaker queue: tidoust
[10:15]	<tidoust>	voip: unmute me
[10:15]	<voip-ld>	tidoust has been unmuted.
[10:16]	<manu1>	tidoust: Just one comment - we had removed MAY SHOULD or MUST from the data model. There should be constraints on the syntax itself, but not the data model.
[10:17]	<manu1>	tidoust: It's fine to say that the data model will be an IRI... but the grammar section should say SHOULD NOT use a bnode.
[10:17]	<manu1>	ack tidoust
[10:17]	<voip-ld>	tidoust has the floor. The speaker queue is empty.
[10:18]	<tidoust>	voip: mute me
[10:18]	<voip-ld>	tidoust has been muted.
[10:27]	<manu1>	Discussion about data model section, relationship to RDF, and ensuring that we address all of the issues brought up by the RDF WG. The group believes that the changes will address everything raised by the RDF WG.
[10:28]	<manu1>	Topic: ISSUE-184: Definition of JSON-LD processor in the API spec
[10:28]	<manu1>	https://github.com/json-ld/json-ld.org/issues/184
[10:28]	<manu1>	markus: In general, I introduced a product which is a JSON-LD processor, which is the only product that the spec defines.
[10:29]	<manu1>	markus: I didn't say anything about parsing because a processor normally uses a JSON parser for parsing.
[10:29]	<manu1>	markus: I didn't say anything about transforming data to a dataset or anything else - it just transforms the document. I'm not sure if that's enough.
[10:30]	<tidoust>	manu: I thought we'd have two classes of product: A "JSON-LD processor" and a "JSON-LD API implementation" (or some other name).
[10:31]	<tidoust>	voip: unmute me
[10:31]	<voip-ld>	tidoust has been unmuted.
[10:33]	<tidoust>	q+
[10:33]	<voip-ld>	Added tidoust to the speaker queue: tidoust
[10:33]	<manu1>	niklas: Could you say something like: your JSON-LD processor must be compliant with the algorithms, it can also be be compliant with the API
[10:34]	<manu1>	manu: I think we should have two products, seems like two different things.
[10:34]	<manu1>	markus: Why would you want to do one and not the other?
[10:34]	<manu1>	niklas: Some programming languages make it difficult to implement the asynchronous API.
[10:34]	<manu1> manu: Some developers would rather have a synchronous API, which we're not going to spec out. We also want to leave room for people to innovate on the API portion, as we may not provide something that is the best API for certain use cases.
[10:35]	<manu1>	tidoust: This is a way to defend the API - it's a way to keep the API in the spec, having two products. Not having two products will create a wall in the RDF working group - only need algorithms, don't need the API. Not having the API tied to a product diminishes its value in the spec.
[10:35]	<tidoust>	voip: mute me
[10:35]	<voip-ld>	tidoust has been muted.
[10:37]	<manu1>	markus: Could we have two levels of implementation? Level 1 and Level 2.
[10:37]	<manu1>	niklas: This is like having a processor supporting XML Infoset... and then having a DOM implementation on top of that.
[10:39]	<manu1>	PROPOSAL: The JSON-LD API specification will define two products: 1) A JSON-LD Processor, and 2) An Implementation of the JSON-LD API, which is dependent on a valid JSON-LD Processor implementation.
[10:41]	<niklasl>	.. 1) A JSON-LD Processor, and 2) A JSON-LD API compliant Processorâ€¦?
[10:41]	<manu1>	manu: What about 1) A JSON-LD Processor, and 2) A JSON-LD Processor and API ?
[10:42]	<mlnt>	maybe, a "JSON-LD Processor conformant to the JSON-LD API" or a "JSON-LD Processor implementing the JSON-LD API"
[10:43]	<niklasl>	1) A JSON-LD Processor, and 2) A JSON-LD API implementation, which is a JSON-LD Processor
[10:45]	<manu1>	PROPOSAL: The JSON-LD API specification will define two products: 1) A JSON-LD Implementation, and 2) A JSON-LD Processor, which is dependent on a valid JSON-LD Implementation.
[10:45]	<mlnt>	+1
[10:45]	<manu1>	+1
[10:45]	<gkellogg>	+0.5
[10:46]	<niklasl>	+1
[10:46]	<tidoust>	+1 (equally happy with other terms)
[10:46]	<manu1>	RESOLVED: The JSON-LD API specification will define two products: 1) A JSON-LD Implementation, and 2) A JSON-LD Processor, which is dependent on a valid JSON-LD Implementation and implements the asynchronous API.
[10:46]	<manu1>	Topic: ISSUE-153: Define error handler behavior
[10:46]	<manu1>	https://github.com/json-ld/json-ld.org/issues/153
[10:48]	<manu1>	manu: Initially I had wanted us to try and figure out a way that a developer could signal that they wanted certain recoverable errors to be recovered automatically, or they'd provide the proper interpretation, or they would signal that processing should stop. A number of folks felt that was overkill, so the proposal on the table is to simplify the error mechanism to just a simple error callback mechanism with an error code and a message.
[10:48]	<manu1>	PROPOSAL: Simplify the error handling by passing an error object to the callbacks which only consists of an error code and an optional error message containing additional information for debugging.
[10:48]	<mlnt>	+1
[10:48]	<niklasl>	+1
[10:48]	<manu1>	+1
[10:48]	<tidoust>	+1
[10:48]	<gkellogg>	+1
[10:49]	<manu1>	RESOLVED: Simplify the error handling mechanism by passing an error object to the callbacks which only consists of an error code and an optional error message containing additional information for debugging.
[10:50]	<manu1>	manu: Do we halt on recoverable errors?
[10:50]	<manu1>	markus: if it's recoverable, is it an error?
[10:50]	<manu1>	gkellogg: Yes, for example - list_of_lists is recoverable, but it's also an error.
[10:51]	<manu1>	gkellogg: I have a feature in my processor which is a 'validate' mode.
[10:51]	<manu1>	niklas: Should the processor stop processing the local object, but continue on error?
[10:51]	<manu1>	gkellogg: I feel like we should process as much as you can, so you can find as many errors as you can.
[10:52]	<manu1>	gkellogg: A way to say 'stop processing' when you encounter an error is useful.
[10:52]	<manu1>	gkellogg: We can have a runtime flag to say "stop when you hit an error" or "continue if you can, on error"
[10:55]	<manu1>	manu: I have a problem if we're going to start halting on errors that should be recoverable. If the XHTML vs. HTML5 debate has taught us anything, it's that processors should try to go as far as they reasonably can, sometimes changing the output drastically in order to not throw an error and "fix" the input to be something reasonable.
[10:57]	<manu1>	mlnt: Yes, but if we do that, the algorithms are going to get far more complex... we have to cover every error case and how to recover from it.
[10:57]	<manu1>	manu: I see your point, but I think that would be better than halting.
[10:58]	<manu1>	gkellogg: I think we need at least two levels of errors - errors and fatal errors. We want to give folks warnings that their input is broken in some way and we "fixed" it.
[11:02]	<manu1>	mlnt: At the moment, the algorithms are defined for well-formed documents only. It's up to the processors to produce warnings if they want to, but they can do that however they want to.
[11:03]	<manu1>	manu: I think that we should use this error/issue mechanism to report both warnings and errors.
[11:03]	<manu1>	markus: Then we risk having this issue drawn out for a much longer time - this issue has already taken a long time to deal with.
[11:03]	<manu1>	markus: The reason this issue has been open for such a long time is that it's difficult to define error behavior for each of these cases.
[11:03]	<manu1>	gkellogg: I think the reason is the complexity of the API callback, not having error recovery conditions.
[11:04]	<niklasl>	We need something like: "it is an error to use @type and @language in the same element. If that happens, a processor should ignore [one of them] and issue a warning." I.e. that is a usage error but doesn't result in a processor error, only a warning? What are the fatal errors?
[11:06]	<niklasl>	q+
[11:06]	<voip-ld>	Added niklasl to the speaker queue: tidoust, niklasl
[11:06]	<tidoust>	q-
[11:06]	<voip-ld>	Removed tidoust from the speaker queue: niklasl
[11:07]	<gkellogg>	q+
[11:07]	<voip-ld>	Added gkellogg to the speaker queue: niklasl, gkellogg
[11:08]	<manu1>	niklasl: I'm wondering where we're going here - the second proposal seems like it may or may not prohibit "Processing MUST be stopped after an error is triggered".
[11:09]	<manu1>	ack niklasl
[11:09]	<voip-ld>	niklasl has the floor. The next speaker is gkellogg.
[11:09]	<manu1>	ack gkellogg
[11:09]	<voip-ld>	niklasl has the floor. The speaker queue is empty.
[11:10]	<manu1>	gkellogg: in RDFa, we recently agreed to describe the redefinition of a prefix as a warning. This may come up in JSON-LD as a warning.
[11:10]	<manu1>	gkellogg: malformed IRIs can also be warnings.
[11:10]	<manu1>	gkellogg: A processor should be able to classify that as an error, but a non-fatal error.
[11:11]	<niklasl>	q+
[11:11]	<voip-ld>	Added niklasl to the speaker queue: niklasl
[11:11]	<manu1>	ack niklasl
[11:11]	<voip-ld>	niklasl has the floor. The speaker queue is empty.
[11:12]	<manu1>	niklasl: I'm thinking of the two different situations, where you have a JSON-LD processor (one is during development - you may have odd data - raise a warning and continue on errors)... in production mode, you might want to halt on the first warning/error. I wouldn't want to define something in the spec where one of these cases is excluded.
[11:13]	<manu1>	markus: In development, you want more debug output - it's not just about warnings/errors. I don't think we need to specify that in the spec.
[11:14]	<manu1>	markus: It's dependent on implementations - some might want to debug, do warnings and errors.
[11:16]	<manu1>	more discussion on how to get warnings to developers.
[11:18]	<manu1>	gkellogg: I think we need 'warnings', 'errors', and 'fatal errors'
[11:19]	<manu1>	niklas: You could just deal with this in the error callback - throw an error if you want to stop, don't do it if you don't.
[11:19]	<manu1>	gkellogg: The issue here is we need some way of saying 'warnings', 'errors', or 'fatal errors'.
[11:19]	<manu1>	markus: What would need to be added?
[11:20]	<manu1>	gkellogg: We just need a flag on the 'error', stating whether it's a 'warning', 'error', or 'fatal error'.
[11:20]	<manu1>	manu: We've burned a lot of call time discussing this. Let's go back to the issue tracker and get some concrete proposals down, straw-poll those through the issue tracker, and revisit this issue when we have something solid we can propose.
[11:26]	<manu1>	Topic: ISSUE-182: Graph vs. DataSet
[11:26]	<manu1>	https://github.com/json-ld/json-ld.org/issues/182
[11:27]	<manu1>	Manu: The RDF WG has kicked this issue back to us and told us that we need to drive the issue. I think we're all in agreement here on what needs to be done. So, let's see if we have consensus here, and if we do, we'll tell the RDF WG that this is where we have consensus.
[11:27]	<manu1>	PROPOSAL: State in the syntax spec that JSON-LD can be used as a RDF graph source. A consumer would just use the default graph and ignore all named graphs in that case. This would allow a server to use, e.g., both Turtle and JSON-LD in content negotiation.
[11:28]	<manu1>	+1
[11:28]	<mlnt>	+1
[11:28]	<gkellogg>	+1
[11:28]	<niklasl>	+1
[11:28]	<gkellogg>	https://github.com/json-ld/json-ld.org/issues/182#issuecomment-10973315
[11:28]	<tidoust>	+1
[11:30]	<manu1>	RESOLVED: State in the syntax spec that JSON-LD can be used as a RDF graph source. A consumer would just use the default graph and ignore all named graphs in that case. This would allow a server to use, e.g., both Turtle and JSON-LD in content negotiation.
[11:31]	<manu1>	gkellogg: This resolution is still a bit problematic. For example, in many of the named graphs cases, the default graph would only contain provenance information... the actual data would be contained in a named graph. This is problematic, so maybe servers would have to serve their data in a different way.
[11:34]	<manu1>	niklasl: The issue with named graphs is that you use them in a different way when you manage your data internally. That's how you handle the quoting of the dataset stuff...
[11:34]	<manu1>	niklasl: When you ask the system for the JSON-LD document for a named graph, you would get the information from that back in a default graph.
[11:35]	<manu1>	gkellogg: Well, another proposal I put forward was [scribe missed]
[11:36]	<manu1>	manu: I think the problem here is that there are many ways to use named graphs and we can't suggest something that is going to work across the board. What we might do is tell people the following: If the top-most JSON Object contains a '@graph' keyword, use that as the 'default graph', if it doesn't contain a '@graph' keyword, use the top-most JSON Object as the default graph. If we do that, then we don't hit the issue that Gregg mentions above.
